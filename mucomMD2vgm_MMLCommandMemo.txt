mucomMD2vgm MMLコマンドメモ
元ネタ: MUSIC LALF MMLコマンドメモ


■ .vgm/.xgmファイル作成手順

  1. 元になるMMLファイルを作成します。
    (1) mucomMD2vgmでは拡張子を便宜上.muMとします。(以下MMLファイルのことを.muMと略します。)
    (2) 文字コードはshiftJIS(改行はCRLF)とします。
    (3) .mucファイル(mucom88win向けMMLファイル)も使用できます。
  

  2-A. mucomMD2vgm.exeを使用する場合
    主にGUIでの使用を想定したプログラムです。ファイル監視と自動起動、vgz変換が可能。

    画面上のボタンの説明(左から)
      ・ファイルを開く
        .muM又は.mucファイルを読み込みます。
        読み込んだら即コンパイルを開始します。

      ・コンパイル
        一度読み込んだ.muMファイルを再コンパイルします。

      ・プレイヤーの自動起動(トグルボタン)
        コンパイル後に生成されたvgmを既定のプログラムで開きます。
        予め、vgm/xgmファイルに対して関連付けを行っておく必要があります。

      ・ファイルの更新監視(トグルボタン)
        一度読み込んだ.muMファイルの監視を開始します。
        更新を検出すると自動的にコンパイルを実行します。
        テキストエディタでmmlを変更し上書き保存した際に自動的にコンパイルさせることを想定した機能です。
        
      ・vgzファイル作成(トグルボタン)(vgmのみ)
        コンパイル時に生成したvgmファイルを自動的にvgzに変換します。

      ・Lコマンド解析処理拡張(トグルボタン)
        mucom88本来のLコマンドの動作をできるだけvgm/xgmで再現するモードになります。

      ・最大レンダリング時間指定(テキストボックス)
        Lコマンド解析処理拡張ボタンを有効にして処理を行ったとき、最大の演奏時間を秒数で指定します。
        データ中のLコマンドの指定の仕方によっては、長時間の演奏が必要なパターンがあるためです。

    画面上の左ペインの説明
      コンパイル後のクロックカウンター値をリスト表示するペインです。
      ・Part
        コンパイルを行うと、パート名(AからKまで)が表示されます。
      ・Chip
        OPN2(YM2612/YM2612X)かDCSG(SN76489)が表示されます。
      ・Counter
        パートごとのクロックカウンター値が表示されます。
        Lコマンドを使用してループさせたい時は、この値が全パートで一致しているか確認すると便利です。

    画面上の右ペインの説明
      コンパイルの進捗、コンパイル時のエラーや警告など、詳細を表示します。


    他の使い方
      エクスプローラなどで、mucomMD2vgm.exeのアイコンの上に作成したMMLファイルをD&Dするとそれをコンパイルします。
      又は、コマンドラインから「mucomMD2vgm.exe ファイル名」と打ち込んでもそのファイルをコンパイルします。

	  UI使用時、
	    UI上にmuc/mumファイルをD&Dするとそれをコンパイルします。
	    F1キーを押すと「ファイルを開く」、
	    F5キーを押すと「コンパイル」を行います。

  
  2-B. mdvc.exeを使用する場合
    mdvc.exeはコマンドプロンプト専用のプログラムです。
    コンパイル対象のmuMファイルをコマンドラインで指定し実行します。
    vgz変換が可能。

  
  3. コンパイルが実行され、エラーやワーニング、例外が表示される。
    又は、エラー無く無事に.vgm/.xgmファイルが.muMと同じフォルダーに生成される。
  

  4. 手頃なvgm/xgmプレイヤーで試聴する。修正が必要であれば1から繰り返す。
  

  5. 完成！悦に入る。自己陶酔モード。
    .xgmの場合はSGDK使ってLet's megadrive programming!!


■ 基本的な記述方法

  .muMは.mucファイルと記述方法は基本、同じです。
  (.mucファイルもそのまま使用できます。)


■ mucom88との違い

  ・対象音源
    mucom88はPC-8801(OPN/OPNA)向けのドライバですが
    本アプリはMEGA DRIVE(GENESIS)(OPN2+DCSG)向けのドライバです。
    mucom88とできるだけ同じように使用できるよう調整しています。

    mucom88     -> OPNA(YM2608)
    mucomMD2vgm -> OPN2(YM2612),DCSG(SN76489)

  ・パート割り
    A  OPN2(YM2612)  Ch.1
    B  OPN2(YM2612)  Ch.2
    C  OPN2(YM2612)  Ch.3 / Ch.3 extend mode op.1
    D  DCSG(SN76489) Ch.1
    E  DCSG(SN76489) Ch.2
    F  DCSG(SN76489) Ch.3
    G  DCSG(SN76489) Ch.4(noise Ch)
    H  OPN2(YM2612)  Ch.4
    I  OPN2(YM2612)  Ch.5
    J  OPN2(YM2612)  Ch.6(FM向け)
    K  OPN2(YM2612)  Ch.6(PCM向け)
    L  OPN2(YM2612)  Ch.3 extend mode op.2
    M  OPN2(YM2612)  Ch.3 extend mode op.3
    N  OPN2(YM2612)  Ch.3 extend mode op.4
    O  OPN2(YM2612)  Ch.6 PCM Ch.2(XGMonly)
    P  OPN2(YM2612)  Ch.6 PCM Ch.3(XGMonly)
    Q  OPN2(YM2612)  Ch.6 PCM Ch.4(XGMonly)

    JとK(O/P/Q)は排他的に使用します。片方がキーオン(発音)するともう片方の音は消えます

  ・音色定義
    mucom88は@コマンドと@%コマンドの２種類の定義が可能ですが、
	mucomMD2vgmでは更に@Nコマンドを追加しています。(Nは大文字です)
	違いは以下のようにAMとSSG-EGのパラメータが指定できる点です。

  @N0
  0 , 7
; AR  DR  SR  RR  SL  TL  KS  ML  DT  AM SSG
  31, 12, 12, 15, 15,  0,  0,  1,  0,  1,  0
  31, 12, 12, 15, 15,  0,  0,  1,  0,  1,  1
  31, 12, 12, 15, 15,  0,  0,  1,  0,  1,  2
  31, 12, 12, 15, 15,  0,  0,  1,  0,  1,  3

  ・コマンド
    mucom88と基本的には同じです。
    mucom88のバージョン1.7のコマンドにあわせています。
    違いは以下の通りです。

   v  ボリュームコマンド（リズム）
      mucom88のリズムパートで使用できる形式に未対応です。

   L  曲全体ループコマンド
      Lコマンド解析処理通常モード
        Aパート以外のLは無視されます。
        またvgm/xgmファイルの制約によりパートごとに長さが異なっていても、全パートは一番長いパートにパディング（
        休符で埋められるイメージです）されます。
      Lコマンド解析処理拡張モード
        mucom88と同じ演奏になるよう、全てのパートのLコマンドを考慮したvgm/xgmを作成します。
		このモードでは、
		一気にループ可能なポイントが現れるまで内部でループ処理が行われながら処理が継続します。
		また、組み合わせによってはなかなかそのポイントが発生しない場合があります。
		そのような状況を解決するために、「Max rendering」(最大レンダリング時間指定)という項目が用意されています。
		初期値600秒を超えてもループポイントが現れない場合は処理をそこで打ち切ります。

   P  ミキサモードコマンド(DCSG)
      Gパート(DCSG Ch.4)にて使用します。
      以下の値を設定することによって動作モードが切り替わります。
      (注意：@コマンドで指定するエンベローププリセットパターン中のPコマンドは無視されます。)
        値      mode          rate  
        P0  ->  periodic      0
        P1  ->  periodic      1
        P2  ->  periodic      2
        P3  ->  periodic      Ch.3連動
        P4  ->  white noise   0
        P5  ->  white noise   1
        P6  ->  white noise   2
        P7  ->  white noise   Ch.3連動

      mode
        periodic    : ファミコンにちょっと似ている音がなります。
                      音域はかなり狭いですが、連動モードにてメロディを演奏することも可能です。

        white noise : 所謂、ノイズを発音します。
                      もっぱらエンベロープと組み合わせてリズムを刻むような使い方をします。

      rate
        0 / 1 / 2   : priodicとwhite noiseの効果の具合がそれぞれ違います。
        Ch.3連動    : DCSGはノイズの周波数をCh.3(mucomMDではFチャンネル)を利用して設定します。
                      例えばo4aとFチャンネルで指定すればそれに応じたノイズ周波数がセットされます。
                      連動してしまうので当然使いにくいことが多いです。
                      潔くFチャンネルのボリュームを0にしてしまうとか、
                      通常は連動機能は使わず固定レートを使用し「ここぞ」というときに連動させるなど、
                      何か工夫が必要になります。


   w  ノイズ周波数コマンド(DCSG)
      未対応です。(Ch.3の周波数を数値で指定できるようにしてもいいのかも。。。)

   vm PCMボリュームモードコマンド(FM PCM)
      未対応です。

   EXON 効果音モード開始コマンド(FMex)
   EXOF 効果音モード停止コマンド(FMex)
   EXn  効果音モードのスロット割り当て(使用するスロットを列挙する)コマンド(FMex)
   S    効果音モードのスロットディチューンコマンド(既存)(FMex)

     ■ EXコマンド群について
        OPN,OPN2,OPNA,OPNBなどOPN系チップは、効果音モードを利用してCH3を最大4分割して演奏することが可能です。

        OPN系は1CH当たり4オペレータのFM音源です。
        通常のCHは周波数を1CH毎にしか設定できないのですが、
        CH3だけは効果音モードを使用するとオペレータ毎に周波数を設定することができます。
        （因みにキーオンはCHに関係なくオペレータ毎に指定可能です。）
    
        この機能を利用する場合にC/L/M/Nパートを使用します。
    
        何分割するかは、通常(あえて変わった使い方をしない限り)、
        CH3に設定したアルゴリズムで決まります。
		(アルゴリズムは@コマンドやyコマンドで設定します。)
        例えば
          アルゴリズムが0から3は、オペレータ4のみの発音なので分割して使用することはあまりありません。
          アルゴリズム4は、オペレータ2と4が発音しますので2分割して使用できます。
          アルゴリズム6は、オペレータ2,3,4が発音しますので3分割して使用できます。
          (アルゴリズム5も、オペレータ2,3,4が発音するのですが1が2,3,4に関わるのでクセがあるかも)
          アルゴリズム7は、オペレータ1,2,3,4の全てが発音しますので4分割して使用できます。

          お勧めはアルゴリズム4です。2オペレータずつ分かれますのでOPL系風味に使用することが可能です。
    
        使用例
          先ずはEXONコマンドで効果音モードを有効にします。
          次にEXコマンドを使用しEXチャンネルにオペレータを割り当てます。
          例えば
            Cパートにオペレータ1と2を割り当て、
            Lパートにオペレータ3と4を割り当てるには以下のようにします。
    
            C EXON EX12
            L      EX34
    
          後はアルゴリズム4の音色を指定しノートを書くだけです。
		  (音色はC/L/M/Nパート４つで共有します。)
            C @123 c4d4e4
            L      gabgab

		注意
		  EXON / EXOF / @ コマンドは Cパートで行ってください。
    
     ■ 効果音モードを利用したスロットディチューンコマンド(S)
        スロットディチューンはチャンネル自体は通常の使用方法ですが、
        FNumの値をスロット毎にずらし、音色の幅を出したいときに使用します。
        要は、この機能を利用することでOPMのDT2と同じような効果を得られます。
		SコマンドとEX系コマンドはチップ的には同じ機能を使用しますので共用できません。
    
   EXM スロットマスクコマンド(FM/FMex)
      発音時に指定のスロットだけキーオンするようになります。
	  キーオンしたいスロットを列挙します。
	  デフォルトは1234で全てのスロットが有効です。
	  一つも発音しない設定はできません。
	  C/L/M/Nは、効果音モードと併用はできません。効果音モード時はEXMの設定は無視します。


  ・タグ
    mucom88winと基本的には同じです。タグ名は大文字小文字を区別しません。
    タグは主に曲情報を設定するのに使用します。
    mucomMD2vgmではvgm/xgmの仕様に沿ってGD3形式に変換されます。意味の近いタグに置き換えます。
	以下の通りです。

　 #Title
               タイトル(日本語以外)
　 #TitleJ
               タイトル(日本語専用)
　 #GameName
               ゲーム名(日本語以外)
　 #GameNameJ
               ゲーム名(日本語専用)
　 #SystemName
               システム名(日本語以外)
			   例えば MEGADRIVE や GENESIS など
　 #SystemNameJ
               システム名(日本語専用)
　 #Composer
               作曲者(日本語以外)
　 #ComposerJ
               作曲者(日本語専用)
　 #Date
               日付(vgmではrelease date)
　 #Author
               作者(vgmではConverted)
　 #Comment
               コメント(vgmではNotes)

    また、曲データごとの動作設定を指定するのにも使用されます。
    違いは以下の通りです。

   #pcm filename
               ADPCM指定タグ
               mucom88形式のADPCMファイルをfilenameに指定します。
               muMファイルと同じパスを参照します。
               (mucomMD2vgmでは内部でPCM形式に変換します。)

   #PcmVolume n
               PCMの音量設定タグ
               設定値nは10進数の数値。範囲は0から255。初期値は255。
               ADPCMからPCMに変換する際の音量を設定します。
               255で最大音量になります。
               この設定の対象は#pcmのみです。

   '@ Pn,"filename"
               PCM個別設定
               n には音色番号、filenameにはwavファイル名を指定します。
               muMファイルと同じパスを参照します。
               読み込めるwavファイルの形式は以下の通りです。
			   vgm形式は
                 8KHz , 8bit , mono , 圧縮なし , unsigned であること。
                 8KHz固定で再生されます。
			   xgm形式は
                 14KHz , 8bit , mono , 圧縮なし , unsigned であること。
                 14KHz固定で再生されます。
               #PcmVolumeの設定は無視されます。
               また、#pcmで定義されている内容が優先で使用されます。
               よって#pcmで定義されていない音色番号を指定するか、
               場合によっては#pcmの内容を削除する必要があります。

   #FileFormat type
               出力するファイルフォーマットを指定します。
               指定可能なtype(値)は
                vgm
                xgm
               の２種です。
               vgmがデフォルトです。
               vgm形式は
                 様々なチップ向けのデータを扱うことが可能なログ形式のフォーマットです。
                 チップに送信するデータが時間情報を挟みながら列挙されているだけなので、
                 再生プログラムを書くのが他の形式と比較して圧倒的に楽であり、
                 また、エミュレーターなどでチップに送られたデータを出力するのに易しい形式です。
                 但し、単純が故に冗長的なデータになるためファイルサイズが巨大になりがちです。
               xgm形式は
                 扱えるチップをOPN2とDCSGに限定したMEGA DRIVE(GENESIS)専用のフォーマットです。
                 基本的にはvgmと同じログ形式のフォーマットですが、
                 チップ数を２つに限定しているのと、単純ではありますがデータを圧縮して記録できる仕組みを持っているため、
                 ファイルサイズを抑えることができます。
                 SGDK(MEGA DRIVEのhome brew向け開発環境)の為に用意された専用の形式で、
                 そのままプログラムに組み込んで使用することが可能です。
                 最大の特徴はソフトウェアによるPCMの4ch同時再生です。
                 パンが個別に振ることができないなどの制約もありますがとても強力な機能になっています。

   #XGMBaseFrame type
               ファイルフォーマットにXGM形式を選択した場合のみ有効なタグです。
               1秒当たりのフレーム数を指定します。
               指定可能なtype(値)は
                ntsc
                pal
               の２種です。
               ntscがデフォルトです。
                 ntsc  フレーム数は 60Hz 。 
                 pal   フレーム数は 50Hz 。
               テンポ、分解能指定と密接な関係にあります。
               ※参考
                 1クロック当たりに割り当てるフレーム数 = XGMBaseFrame * (60 * 4) / ClockCount / tempo
                 例えば
                   ntsc , clockcount=192 , tempo=120
                 のとき
                   60 * 60 * 4 / 192 / 120 = 0.625 (frame/clock)
                 ４分音符は
                   192 / 4 = 48 (clock)
                 で48クロックなので
                   0.625 * 48 = 30 (frame)
                 で30フレームとなります。
                 テンポが120ということは１秒間(60frame)で４分音符(30frame)が2回演奏できますから合っていますね。

                 VGM形式に比べて非常に値が小さい事に注意してください。(ちなみにVGM形式の場合は44100Hz固定。)
                 ここでのntsc、palは日本、ヨーロッパなどのテレビの１秒間あたりの画面を書き換える回数を意味しています。
                 他の多くのゲーム機はこのテレビの映像を書き換えるタイミングに合わせて音楽の演奏処理を行います。
                 メガドライブで動作するXGM形式も同じ仕組みになっています。


以上
